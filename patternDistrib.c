/*************************************
* patternDistrib is a part of CisFinder software
* http://lgsun.grc.nia.nih.gov/CisFinder
*
* Function: finds sites in a sequence that match to motifs specified by PFM
* 
* Syntax:
* patternDistrib -i scanResults -f frequencyOutput -a abundanceOutput [-int intervalForFreq]
* 
* Comments:
* (a) scanResults = file generated by "patternScan" program
* (b) frequencyOutput = shows the frequency distribution of binding sites along 
* sequences aligned by their starting position.
* (c) abundanceOutput = shows the number of motif matches in each sequence. It can be used
* for classifying sequences based on the composition of binding motifs.
* (d) intervalForFreq = interval (bp) used for calculation of frequencyOutput 
* file (default = 100bp).
* See file formats in the readme.txt file
* 
* Author: Alexei Sharov   10/08/2008
* Lab. of Genetics, National Institute on Aging (NIA/NIH)
* Phone: 410-558-8556   Email: sharoval@mail.nih.gov
* 
* See disclaimer in the "readme.txt" file
* If you use this program in your research, please cite:
* Sharov, A.A. and Ko, M.S.H. 2008. Development of CisFinder - an express 
* algorithm to identify over-represented DNA sequence motifs and its application 
* to genome-wide chromatin immunoprecipitation assays for embryonic stem cells.
* BMC Bioinformatics (in review).
**************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#define MAXINT 65536

typedef struct position_st{
	int num;
	int *TFid;
	int *dir;
	long *pos;
	long *seq;
	float *score;
}POSITION;
typedef struct param_st{
	char *inputFile;
	char *frequencyOutFile;
	char *abundanceOutFile;
	int interval;
}PARAM;


/*************************************************************************/
void sortem   (long ie, float *a, int iperm, float *b,
		float *c, float *d, float *e, float *f, float *g, float *h)
/*************************************************************************/
{
	 long i, j, k, m, p, q, iring;
	 long lt[64], ut[64];
	 float ta, tb, tc, td, te, tf, tg, th, xa, xf, xg;
	 float xh, xe, xd, xc, xb;
	 int i__1;

	 /* Function Body */
	 j = ie-1;
	 m = 1;
	 i = 0;
	 iring = iperm + 1;
	 if (iperm > 7) {
		 iring = 1;
	 }

/* If this segment has more than two elements  we split it */
L10:	 if ((i__1 = j - i - 1) < 0) {
	goto L100;
	 } else if (i__1 == 0) {
	goto L90;
	 } else {
	goto L15;
	 }

/* p is the position of an arbitrary element in the segment we choose the 
* middle element. Under certain circumstances it may be advantageous 
* to choose p at random. */

L15:
	 p = (j + i) / 2;
	 ta = a[p];
	 a[p] = a[i];
	 switch (iring) {
	case 1:  goto L21;
	case 2:  goto L19;
	case 3:  goto L18;
	case 4:  goto L17;
	case 5:  goto L16;
	case 6:  goto L161;
	case 7:  goto L162;
	case 8:  goto L163;
	 }
L163:	 th = h[p];
	 h[p] = h[i];
L162:	 tg = g[p];
    g[p] = g[i];
L161:	 tf = f[p];
    f[p] = f[i];
L16:	 te = e[p];
	 e[p] = e[i];
L17:	 td = d[p];
    d[p] = d[i];
L18:	 tc = c[p];
    c[p] = c[i];
L19:	 tb = b[p];
	 b[p] = b[i];
L21: /* Start at the beginning of the segment, search for k such that a(k)>t */
    q = j;
    k = i;
L20:	 ++k;
	 if (k > q) {
	goto L60;
	 }
    if (a[k] <= ta) {
	goto L20;
    }
/* Such an element has now been found now search for a q such that a(q)<t 
* starting at the end of the segment. */
L30:  if (a[q] < ta) {
	goto L40;
	 }
    --q;
    if (q > k) {
	goto L30;
    }
    goto L50;

/* a(q) has now been found. we interchange a(q) and a(k) */

L40: xa = a[k];
    a[k] = a[q];
    a[q] = xa;
    switch (iring) {
	case 1:  goto L45;
	case 2:  goto L44;
	case 3:  goto L43;
	case 4:  goto L42;
	case 5:  goto L41;
	case 6:  goto L411;
	case 7:  goto L412;
	case 8:  goto L413;
    }
L413:     xh = h[k];
    h[k] = h[q];
	 h[q] = xh;
L412:	 xg = g[k];
    g[k] = g[q];
	 g[q] = xg;
L411:    xf = f[k];
	 f[k] = f[q];
    f[q] = xf;
L41:	 xe = e[k];
	 e[k] = e[q];
    e[q] = xe;
L42:	 xd = d[k];
    d[k] = d[q];
    d[q] = xd;
L43:    xc = c[k];
	 c[k] = c[q];
	 c[q] = xc;
L44:	 xb = b[k];
    b[k] = b[q];
	 b[q] = xb;
L45:
/* Update q and search for another pair to interchange: */
    --q;
   goto L20;
L50:    q = k - 1;
L60:
/* The upwards search has now met the downwards search: */
    a[i] = a[q];
    a[q] = ta;
   switch (iring) {
	case 1:  goto L65;
	case 2:  goto L64;
	case 3:  goto L63;
	case 4:  goto L62;
	case 5:  goto L61;
	case 6:  goto L611;
	case 7:  goto L612;
	case 8:  goto L613;
    }
L613:	 h[i] = h[q];
	 h[q] = th;
L612:    g[i] = g[q];
	 g[q] = tg;
L611:    f[i] = f[q];
    f[q] = tf;
L61:    e[i] = e[q];
	 e[q] = te;
L62:	 d[i] = d[q];
    d[q] = td;
L63:    c[i] = c[q];
    c[q] = tc;
L64:    b[i] = b[q];
    b[q] = tb;
L65:

/* The segment is now divided in three parts: (i,q-1),(q),(q+1,j) */
/* store the position of the largest segment in lt and ut */
    if (q << 1 <= i + j) {
	goto L70;
 }
 lt[m - 1] = i;
 ut[m - 1] = q - 1;
 i = q + 1;
 goto L80;
L70:	 lt[m - 1] = q + 1;
	 ut[m - 1] = j;
	 j = q - 1;
/* Update m and split the new smaller segment */
L80:	 ++m;
	 goto L10;

/* We arrive here if the segment has  two elements we test to see if */
/* the segment is properly ordered if not, we perform an interchange */
L90:
    if (a[i] <= a[j]) {
	goto L100;
    }
	 xa = a[i];
	 a[i] = a[j];
	 a[j] = xa;
	 switch (iring) {
	case 1:  goto L95;
	case 2:  goto L94;
	case 3:  goto L93;
	case 4:  goto L92;
	case 5:  goto L91;
	case 6:  goto L911;
	case 7:  goto L912;
	case 8:  goto L913;
    }
L913:	 xh = h[i];
	 h[i] = h[j];
	 h[j] = xh;
L912:    xg = g[i];
    g[i] = g[j];
	 g[j] = xg;
L911:	 xf = f[i];
    f[i] = f[j];
	 f[j] = xf;
L91:	 xe = e[i];
    e[i] = e[j];
    e[j] = xe;
L92:	 xd = d[i];
	 d[i] = d[j];
    d[j] = xd;
L93:	 xc = c[i];
	 c[i] = c[j];
	 c[j] = xc;
L94:    xb = b[i];
    b[i] = b[j];
	 b[j] = xb;
L95:

/* If lt and ut contain more segments to be sorted repeat process: */
L100:	 --m;
	 if (m <= 0) {
	goto L110;
	 }
	 i = lt[m - 1];
	 j = ut[m - 1];
	 goto L10;
L110:	 return;
} /* sortem_ */

/***********************************************/
void check (void *x)
/***********************************************/
{
	if (!x){
		printf("ERROR: Out of memory\n");
		exit(0);
	}
}

/***********************************************/
void error_message (char *message)
/***********************************************/
{
	printf("ERROR: %s\n", message);
	exit(0);
}

/***********************************************/
void  reverse_string (char *str) 
/***********************************************/
{
int i, len;
char *newstr;
len=strlen(str);
check(newstr = (char*)malloc((len+1)*sizeof(char)));
for(i=0; i<len; ++i){ newstr[len-i-1]=str[i]; }
memcpy(str,newstr,len);
free(newstr);
}

/***********************************************/
int  split_string (char *string, char *items[], int num)
/***********************************************/
{
char *ch;
int i=0;

ch = strchr(string,'\n');
if(ch) *ch = '\0';
ch = string;
while(1){
	items[i] = ch;
	ch = strchr(ch,'\t');
	if(ch) *ch = '\0';
	else break;
	if(i>=num-1) break;
	ch++;
	i++;
}
return(i+1);
}

/***********************************************/
char  *truncate_filename(char *filename) 
/***********************************************/
{
char *ch;
ch = strrchr(filename,'/');
if(!ch) ch = filename;
else ++ch;
return(ch);
}

/***********************************************/
char *copy_string(char *str)
/***********************************************/
{
char *ch=NULL;
int len;
len = strlen(str);
if(len){
	check(ch = (char*)malloc((len+1)*sizeof(char)));
	strcpy(ch,str);
}
return(ch);
}

/***********************************************/
int *estimate_frequency(POSITION *positions, long nSeq, long nMotifs, long maxLength, int *motifLen, PARAM *p)
/***********************************************/
{
int *frequency;
long i, j, pos, ipos, iseq, ncol, TFid, *nTF, *nnnTF;
float **scores, **scoreThresh;

check(nTF = (long*)calloc(nMotifs,sizeof(long)));
check(nnnTF = (long*)calloc(nMotifs*3,sizeof(long)));
for(iseq=0; iseq<nSeq; ++iseq){
	for(i=0; i<positions[iseq].num; ++i){
		TFid = positions[iseq].TFid[i];
		if(!TFid) continue;
		nTF[TFid]++;
	}
}
check(scores = (float**)malloc(nMotifs*sizeof(float*)));
check(scoreThresh = (float**)malloc(nMotifs*sizeof(float*)));
for(i=0; i<nMotifs; ++i){
	check(scores[i] = (float*)malloc(nTF[i]*sizeof(float)));
	check(scoreThresh[i] = (float*)malloc(3*sizeof(float)));
	nTF[i] = 0;
}
for(iseq=0; iseq<nSeq; ++iseq){
	for(i=0; i<positions[iseq].num; ++i){
		TFid = positions[iseq].TFid[i];
		if(!TFid) continue;
		scores[TFid][nTF[TFid]++] = positions[iseq].score[i];
	}
}
for(i=1; i<nMotifs; ++i){
	long k, N;
	N = nTF[i];
	k = N;
	sortem(N, scores[i], 0, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	for(j=0; j<3; ++j){
		k /= 2;
		scoreThresh[i][j] = scores[i][N-k-1];
	}
}
ncol = maxLength/p->interval+1;
check(frequency = (int*)calloc(nMotifs*ncol*5,sizeof(int)));
for(iseq=0; iseq<nSeq; ++iseq){
	for(i=0; i<positions[iseq].num; ++i){
		TFid = positions[iseq].TFid[i];
		if(!TFid) continue;
		ipos = (positions[iseq].pos[i]+motifLen[TFid]+0.5) / p->interval;
		//printf("B %d %d %d\n",iseq,ipos,TFid);
		if(positions[iseq].dir[i] > 0)
			frequency[((TFid*5)+0)*ncol+ipos]++;
		else
			frequency[((TFid*5)+1)*ncol+ipos]++;
		long k = nTF[TFid];
		for(j=0; j<3; ++j){
			k /= 2;
			if(positions[iseq].score[i] >= scoreThresh[TFid][j]){
				if(positions[iseq].score[i]==scoreThresh[TFid][j] && nnnTF[j*nMotifs+TFid] > k) continue;
				frequency[((TFid*5)+2+j)*ncol+ipos]++;
				nnnTF[j*nMotifs+TFid]++;
			}
		}
	}
}
for(i=0; i<nMotifs; ++i){
	free(scores[i]);
	free(scoreThresh[i]);
}
free(scores);
free(scoreThresh);
free(nTF);
free(nnnTF);
return(frequency);
}

/***********************************************/
void  print_frequency_table(int *frequency, char **motifNames, long nMotifs, long maxLength, PARAM *p)
/***********************************************/
{
long i, j, pos, ipos, iseq, ncol, TFid;
FILE *fp;
static char *types[5]={"+","-","1/2","1/4","1/8"};

fp = fopen(p->frequencyOutFile,"w");
ncol = maxLength/p->interval+1;
fprintf(fp,"MotifName\tStrand-Quantile");
for(i=0; i<ncol; ++i) fprintf(fp,"\t%d",i*p->interval+p->interval/2);
fprintf(fp,"\n");
for(TFid=1; TFid<nMotifs; ++TFid){
	for(j=0; j<5; ++j){
		fprintf(fp,"%s\t%s",motifNames[TFid],types[j]);
		for(i=0; i<ncol; ++i){
			fprintf(fp,"\t%d",frequency[((TFid*5)+j)*ncol+i]);
		}
		fprintf(fp,"\n");
	}
}
fclose(fp);
return;
}

/***********************************************/
int   *estimate_abundance(POSITION *positions, long nSeq, long nMotifs)
/***********************************************/
{
int *abundance;
long i, iseq, TFid;

check(abundance = (int*)calloc(nMotifs*nSeq,sizeof(int)));
for(iseq=0; iseq<nSeq; ++iseq){
	for(i=0; i<positions[iseq].num; ++i){
		TFid = positions[iseq].TFid[i];
		if(!TFid) continue;
		abundance[iseq*nMotifs+TFid]++;
	}
}
return(abundance);
}

/***********************************************/
void  print_abundance_table(int *abundance, char **motifNames, long nMotifs, char **seqNames, long nSeq, PARAM *p)
/***********************************************/
{
long i, iseq, TFid;
FILE *fp;

fp = fopen(p->abundanceOutFile,"w");
fprintf(fp,"SeqName");
for(TFid=1; TFid<nMotifs; ++TFid) fprintf(fp,"\t%s",motifNames[TFid]);
fprintf(fp,"\n");
for(iseq=0; iseq<nSeq; ++iseq){
	fprintf(fp,"%s",seqNames[iseq]);
	for(TFid=1; TFid<nMotifs; ++TFid){
		fprintf(fp,"\t%d",abundance[iseq*nMotifs+TFid]);
	}
	fprintf(fp,"\n");
}
fclose(fp);
return;
}

/***********************************************/
POSITION  *read_input_file (char *filename, char **motifNames, long *nMotif, char **seqNames, long *nSeq, long *maxLength, int *motifLen)
/***********************************************/
{
char *buffer, *ch, *items[10], *seqOld;
long i, j, gap, ind, rep, cont, len, Nseq, Nmotif, N, *seqID, *pos;
int *TFid, *dir;
float *score;
FILE *fp;
POSITION *positions;

check(positions = (POSITION*)malloc(MAXINT*sizeof(POSITION)));
check(buffer = (char*)malloc(3000*sizeof(char)));
check(TFid = (int*)malloc(MAXINT*sizeof(int)));
check(dir = (int*)malloc(MAXINT*sizeof(int)));
check(pos = (long*)malloc(MAXINT*sizeof(long)));
check(seqID = (long*)malloc(MAXINT*sizeof(long)));
check(score = (float*)malloc(MAXINT*sizeof(float)));
check(seqOld = (char*)calloc(10000,sizeof(char)));
fp = fopen(filename,"r");
ch = truncate_filename(filename);
if(!fp){ printf("ERROR: Input file %s not found",ch); exit(0); }
int count=0;
Nseq = 0;
Nmotif = 1;
motifNames[Nseq] = copy_string("NONE");
N = 0;
*maxLength = 0;
fgets(buffer,2999,fp); //Skip header
while(fgets(buffer,2999,fp)){
	int n = split_string(buffer,items,10);
	if(strstr(buffer,"Headers") || strstr(buffer,"Parameters")) continue;
	//printf("%s %s\n",seqOld,items[1]);
	if(N && strcmp(seqOld,items[1])){
		positions[Nseq].num = N;
		check(positions[Nseq].TFid = (int*)malloc(N*sizeof(int)));
		check(positions[Nseq].dir = (int*)malloc(N*sizeof(int)));
		check(positions[Nseq].pos = (long*)malloc(N*sizeof(long)));
		check(positions[Nseq].seq = (long*)malloc(N*sizeof(long)));
		check(positions[Nseq].score = (float*)malloc(N*sizeof(float)));
		memcpy(positions[Nseq].TFid,TFid,N*sizeof(int));
		memcpy(positions[Nseq].dir,dir,N*sizeof(int));
		memcpy(positions[Nseq].pos,pos,N*sizeof(long));
		memcpy(positions[Nseq].seq,seqID,N*sizeof(long));
		memcpy(positions[Nseq].score,score,N*sizeof(float));
		//printf("seq %s\n",seqNames[i]);
		seqNames[Nseq] = copy_string(seqOld);
		Nseq++;
		N = 0;
	}
	sscanf(items[4],"%ld",&pos[N]);
	sscanf(items[5],"%f",&score[N]);
	if(*maxLength < pos[N]) *maxLength = pos[N];
	if(items[2][0] =='-') dir[N]=-1;
	else dir[N]=1;
	for(i=0; i<Nmotif; ++i){
		if(!strcmp(motifNames[i],items[0])) break;
	}
	TFid[N] = i;
	if(i==Nmotif){
		motifNames[i] = copy_string(items[0]);
		motifLen[i] = atoi(items[3]);
		//printf("motif %s\n",motifNames[i]);
		++Nmotif;
	}
	//printf("A %s %s %d %d\n",items[0],items[1],dir[N],pos[N]);
	strcpy(seqOld,items[1]);
	N++;
}		
if(N){
	positions[Nseq].num = N;
	check(positions[Nseq].TFid = (int*)malloc(N*sizeof(int)));
	check(positions[Nseq].dir = (int*)malloc(N*sizeof(int)));
	check(positions[Nseq].pos = (long*)malloc(N*sizeof(long)));
	check(positions[Nseq].seq = (long*)malloc(N*sizeof(long)));
	check(positions[Nseq].score = (float*)malloc(N*sizeof(float)));
	memcpy(positions[Nseq].TFid,TFid,N*sizeof(int));
	memcpy(positions[Nseq].dir,dir,N*sizeof(int));
	memcpy(positions[Nseq].pos,pos,N*sizeof(long));
	memcpy(positions[Nseq].seq,seqID,N*sizeof(long));
	memcpy(positions[Nseq].score,score,N*sizeof(float));
	seqNames[Nseq] = copy_string(seqOld);
	Nseq++;
}
*nMotif = Nmotif;
*nSeq = Nseq;
free(TFid);
free(dir);
free(pos);
free(seqID);
free(seqOld);
free(buffer);
free(score);
return(positions);
}

/***********************************************/
PARAM *read_parameters (int nargs, char **argv)
/***********************************************/
{
PARAM *p;
int iarg=1, score=0;
static char *syntax = "patternDistrib -i scanResults -f frequencyOutput -a abundanceOutput [-int intervalForFreq]\n";

if(nargs < 2){ printf("%s\n",syntax); exit(0); }
p = (PARAM*)calloc(1,sizeof(PARAM));
p->interval = 100;
while(iarg < nargs){
	if(!strcmp(argv[iarg],"-i") && iarg < nargs-1){ p->inputFile = copy_string(argv[++iarg]); }
	else if(!strcmp(argv[iarg],"-f") && iarg < nargs-1) p->frequencyOutFile = copy_string(argv[++iarg]);
	else if(!strcmp(argv[iarg],"-a") && iarg < nargs-1) p->abundanceOutFile = copy_string(argv[++iarg]);
	else if(!strcmp(argv[iarg],"-int") && iarg < nargs-1) sscanf(argv[++iarg],"%d",&p->interval);
	else{
		printf("ERROR: Wrong option %s\n", argv[iarg]);
		exit(0); 
	}
	++iarg;
}
if(!p->interval) error_message("Interval should be >0");
if(!p->inputFile) error_message("Specify input file name");
if(!p->frequencyOutFile && !p->abundanceOutFile) error_message("Specify output file(s)");
if(!p->abundanceOutFile) error_message("Specify abundance output file name");
return(p);
}

/***********************************************/
int main (int argc, char **argv) 
/***********************************************/
{
char **motifNames, **seqNames, *ch;
long nSeq, nMotifs, maxLength;
POSITION *positions;
PARAM *p;
int *frequency, *abundance, *motifLen;

p = read_parameters(argc, argv);

check(motifNames = (char**)malloc(5000*sizeof(char*)));
check(seqNames = (char**)malloc(MAXINT*sizeof(char*)));
check(motifLen = (int*)malloc(MAXINT*sizeof(int)));
positions = read_input_file(p->inputFile,motifNames,&nMotifs,seqNames,&nSeq,&maxLength,motifLen);
if(nMotifs==1) error_message("No motifs found in the input fasta file!");
printf("Input file processed: %d sequences, %d motifs, %d max position\n",nSeq,nMotifs-1,maxLength);
if(p->frequencyOutFile){
	frequency = estimate_frequency(positions,nSeq,nMotifs,maxLength,motifLen,p);
	print_frequency_table(frequency,motifNames,nMotifs,maxLength,p);
}
if(p->abundanceOutFile){
	abundance = estimate_abundance(positions,nSeq,nMotifs);
	print_abundance_table(abundance,motifNames,nMotifs,seqNames,nSeq,p);
}
return(0);
}
